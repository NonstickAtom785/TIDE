edit:
;Inputs:
;   need edit_bottom,edit_top,edit_end,edit_ptr,
;   key_to_tok
;   edit_hook
;   get_tok_size
  call getKeyDebounce
  ld a,1<<insertmode
  ld (flags+keyflags),a
rerender_edit:
  set rerender,(iy+editorflags)
edit_loop:
  call rerender_editor

;Check if [ON] is being pressed
  in a,(4)
  and 8
  ret z

;blink the cursor
  ld hl,curcount
  dec (hl)
  jr nz,+_
  ld (hl),CUR_COUNT_RESET
  ld a,(flags+keyflags)
  xor 1<<cursorblink
  ld (flags+keyflags),a
  and 1<<cursorblink
  call curblink
  call UpdateLCD
_:


  call getKeyDebounce
  or a
  jr z,edit_loop
  call process_keypress
  jr c,edit_loop
;HL is a pointer to a size-prefixed tok string
  ex de,hl
  ld hl,(edit_ptr)
  call edit_hook      ;input and output: HL cur tok, DE new size-prefixed tokstr
  call replacetokens
  ret c               ;there was an error
  jr rerender_edit

curblink:
;z set if blinking off
;nz if blinking on
  ld a,(char_save)
  jr nz,curblinkon
;need to redraw the char
  ld hl,(textrow)
  ld (texttemp),hl
  call VPutC
  ld hl,(texttemp)
  ld (textrow),hl
  ret

curblinkon:
  call chardim    ;returns D is width, E is height
  ld bc,(textrow)
  bit insertmode,(iy+keyflags)
  jr z,+_
  ld d,1
_:
  jp xorRect

chardim:
  ld de,$0406
  ret

replacetokens:
;HL points to the current tokens
;DE points to the new tokens
;BC is the number of tokens to replace
;returns carry if there was an error
  push de
  push hl
  push de
  call getsizetokstr
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ex de,hl
;DE is pointer to new string
;HL is the new size
;BC is the old size
  or a
  sbc hl,bc

  ld b,h
  ld c,l
  pop hl
  call nz,insertmem
  pop de
  ret c     ;maybe want to throw an error?
;HL points to where to write
;DE points to the size-prefixed string to write
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld a,b
  or c
  ret z
  ldir
  ;DE is the new edit_ptr ?
  ld (edit_ptr),de
  ret

rerender_editor:
  bit rerender,(iy+editorflags)
  ret z
  res rerender,(iy+editorflags)

  call clrgbuf
  ld hl,0
  ld (textrow),hl
  ld hl,(edit_bottom)
  call VPutTokStr
  di
  jp UpdateLCD
VPutTokStr:
  ld de,(edit_end)
  ld bc,0
  or a
  sbc hl,de
  add hl,de
  ret nc

  call get_tok_str
  ret z
  push hl
  ex de,hl
  call VPutS
  pop hl
  ld a,(textrow)
  cp 64
  jr c,VPutTokStr
  ret

get_tok_str:
;return HL points to the next token
;       DE points to the token string
;       z flag set if end-of-string token
  ld a,(hl)
  or a
  ret z
  cp $3F
  jr z,+_
  call isAxeTok
  jr z,get_tok_str_no_EOS
  bcall(_IsA2ByteTok)
  push af
  push hl
  bcall(_Get_Tok_Strng)
  ld de,OP3
  pop hl
  pop af
  inc hl
  ret nz
  inc hl
get_tok_str_no_EOS:
  or 1
  ret
_:
  sub $3E   ;char 0x01 is used as a control char to jump down a line
  inc hl
  ld de,+_
  ret
_:
  .db 1,0

isAxeTok:
  cp 'W'
  jr z,checkWhite
  cp 'I'
  jr z,checkInvert
isRectTok:
  cp $BB
  ret nz
  inc hl
  ld a,(hl)
  cp $2D    ;ref(
  jr nz,isAxeTok_decExit
  inc hl
  ld de,s_Rect
  ret
isAxeTok_decExit:
  dec hl
  ret

checkWhite:
  inc hl
  ld a,(hl)
  cp $9C
  jr nz,+_
  inc hl
  ld de,s_WhiteLine
  ret
_:
  call isRectTok
  jr nz,isAxeTok_decExit
  ld de,s_WhiteRect
  ret

checkInvert:
  inc hl
  ld a,(hl)
  cp $9C
  jr nz,+_
  inc hl
  ld de,s_InvertLine
  ret
_:
  call isRectTok
  jr nz,isAxeTok_decExit
  ld de,s_InvertRect
  ret

s_InvertRect:
  .db 3 \ .dw s_Invert
  .db 3 \ .dw s_Rect
  .db 0
s_WhiteRect:
  .db 3 \ .dw s_White
s_Rect:
  .db "Rect(",0

s_InvertLine:
  .db 3 \ .dw s_Invert
  .db 3 \ .dw s_Line
  .db 0
s_WhiteLine:
  .db 3 \ .dw s_White
s_Line:
  .db "Line(",0

s_White:
  .db "White",0
s_Invert:
  .db "Invert",0


edit_hook:
  ret

delcurtok:
  push af
  set rerender,(iy+editorflags)
  ld hl,(edit_ptr)
  call get_tok_size
  ld hl,(edit_ptr)
  call delmem
  pop af
  ret

get_tok_size:
;HL points to the token
;return HL pointing to the next token and BC as the size
;First, verify that there are even bytes left!
  ld de,(edit_end)
  ld bc,0
  or a
  sbc hl,de
  add hl,de
  ret nc
  ;if HL>=DE, should exit with BC=0


;here is the custom stuff
_IsA2ByteTok  = 42A3h
  ld a,(hl)
  inc hl
  inc c
  cp 'W'
  jr nc,+_

  bcall(_IsA2ByteTok)
  ret nz
get_tok_size_inc:
  inc hl
  inc c
  ret
get_tok_size_dec:
  dec hl
  ret
_:
  ld a,(hl)
  cp $9C      ;Line
  jr z,get_tok_size_inc
  cp $BB
  ret nz
  inc hl
  ld a,(hl)
  cp $2D      ;ref(
  jr nz,get_tok_size_dec
  inc c
  inc c
  inc hl
  ret

process_keypress:
key_to_tok:
;return carry if no token returned
;return HL as a pointer to the null-terminated token string
;       BC as the number of tokens to overwrite,
  cp 31   ;prgm token
  jr nz,key_to_tok_convert
  bit shift,(iy+keyflags)
  res shift,(iy+keyflags)
  ld ix,menu_prgm
  ld hl,menu_prgm_header
  jr z,+_
  ld hl,menu_draw_header
  ld ix,menu_draw
_:
  ld bc,$1008
  ld de,$4030
  call menu
  set rerender,(iy+editorflags)
  bit insertmode,(iy+keyflags)
  jr z,+_
  ld c,b
_:

  ccf
  ret

key_to_tok_convert:
  call getKeyTok
  ret c
;else, the key was a token
  ;DE is the token, D is 0 if a 1-byte token

;These will only replace 1 token, so set BC to 1
  ld bc,1

;write the token to a spot in RAM
  xor a
  ld hl,OP1+4
  ld (hl),a
  dec hl
  inc a
  ld (hl),e
  dec hl
  inc d
  dec d
  jr z,+_
  ld (hl),d
  inc a
  dec hl
_:

;Now write the size bytes of the token string (# of bytes, not tokens)
  ld (hl),b
  dec hl
  ld (hl),a

;If the token is a newline, we'll actually insert, even in overwrite mode
  inc d
  dec d
  jr nz,+_
  ld a,e
  cp $3F
  jr z,key_to_tok_replace0
_:

;If insert mode, we'll actually replace 0 bytes
  bit insertmode,(iy+keyflags)
  jr z,+_
key_to_tok_replace0:
  ld c,b
_:

  or a
  ret
